% @author Max Lapshin <max@maxidoors.ru>.
% @license MIT License
% @doc
% This file is a wrapper on top of autogenerated nfs_prot3_clnt
%
% It exports following functions:
%
% 1) init/1
% {ok, Remote} = nfs3:init("nfs://uid:gid@host/mount//path").
%
% Mention that "mount" must be a real mountpoint, that is exported via NFS and
% path can be a subfolder. This client can virtually mount a subfolder of an exported mount
%
% 2) scan/1, scan/2
%
% {ok, Files} = nfs3:scan(Remote).
%
% Returns full list of files in the root or subfolder. Mention that root can be subfolder of exported root
%
% 3) list_dir/2
%
% {ok, Files} = nfs3:list_dir(Remote, Path)
%
% 4) create/2
%
% {ok, Ref, Remote1} = nfs3:create(Remote, Path),
%
% File is created with 0644 with handle Ref that is used in write/4 call
%
% 5) write/4
%
% ok = nfs3:write(Remote, Ref, Offset, Binary).
%
% Writes Binary at Offset in opened file Ref
%
% 6) delete_r/2
%
% {ok, Remote1} = nfs3:delete_r(Remote, Path).
%
% Deletes file Path and recursively deletes all empty containing its folders
%
-module(nfs3).
-author('Max Lapshin <max@maxidoors.ru.').


-include_lib("kernel/include/file.hrl").

-export([init/1, read_file/2, scan/1, scan/2, list_dir/2, create/2, write/4, delete_r/2]).


-record(fsinfo, {
  rtmax,
  rtpref,
  rtmult,
  wtmax,
  wtpref,
  wtmult,
  dtpref,
  maxfs_size,
  time_delta,
  props
}).

-record(remote, {
  c,
  root,
  real_root,
  fsinfo,
  read_size,
  cache = [],
  cache_hit = 0,
  cookie_verf = <<0,0,0,0,0,0,0,0>>
}).

-record(entry, {
  path,
  object,
  attr
}).

init(URL) when is_binary(URL) ->
  init(binary_to_list(URL));

init("nfs://"++URL) ->
  Options = [],
  {ok, {_, Auth, Host, _, Path, _}} = http_uri:parse("http://"++URL),
  [Uid, Gid] = [list_to_integer(L) || L <- string:tokens(Auth, ":")],


  {ok,M} = rpc_client:open(Host,100005,3,udp),
  {ok,void} = mount3_clnt:mountproc_null_1(M), % Check if server is ok
  {ok, Mounts_} = mount3_clnt:mountproc_export_3(M),
  _Mounts = unpack_mounts(Mounts_),
  % lists:keyfind(Path, 1, Mounts) =/= false orelse error({no_export,Path,Mounts}),
  {MountRoot, MountPath} = case binary:split(iolist_to_binary(Path), <<"//">>) of
    [MR, MP] -> {MR, MP};
    [MR] -> {MR, <<>>}
  end,
  set_auth(M, [{uid,Uid},{gid,Gid}|Options]),
  {ok, {'MNT3_OK',{RealRoot,_}}} = mount3_clnt:mountproc_mnt_3(M,MountRoot),
  rpc_client:close(M),

  {ok,C} = rpc_client:open(Host,100003,3,udp),
  set_auth(C, [{uid,Uid},{gid,Gid}|Options]),
  rpc_client:set_queue_limit(C, 15000),


  {ok, {'NFS3_OK', Info}} = nfs_prot3_clnt:nfsproc3_fsinfo_3(C, {{RealRoot}}),
  {_, RTmax, RTpref, RTmult, WTmax, WTpref, WTmult, DTpref, MaxFSize, TimeDelta, Props} = Info,
  FSInfo = #fsinfo{rtmax = RTmax, rtpref = RTpref, rtmult = RTmult,
  wtmax = WTmax, wtpref = WTpref, wtmult = WTmult, dtpref = DTpref, 
  maxfs_size = MaxFSize, time_delta = TimeDelta, props = Props},

  Remote1 = #remote{
    c = C,
    real_root = RealRoot,
    root = RealRoot,
    fsinfo = FSInfo,
    read_size = lists:min([RTpref,65536])
  },

  {ok, Root, Remote2} = mkdir_p(Remote1, MountPath),

  {ok, Remote2#remote{root = Root}}.



set_auth(C, Options) ->
  Stamp = 0,
  Name = <<"">>,
  {uid,Uid} = lists:keyfind(uid, 1, Options),
  {gid,Gid} = lists:keyfind(gid, 1, Options),
  Gids = [],
  rpc_client:set_auth(C, {auth_sys, Stamp, Name, Uid, Gid, Gids}).

unpack_mounts(void) -> [];
unpack_mounts({Dir, Groups, Next}) -> [{Dir, unpack_netgroups(Groups)}|unpack_mounts(Next)].

unpack_netgroups(void) -> [];
unpack_netgroups({Group,Groups}) -> [Group|unpack_netgroups(Groups)].




% pread(C, Obj, Offset, Count) ->
%   Chunks = chunks(Offset, Count),
%   Self = self(),
%   Worker = proc_lib:spawn_link(fun() ->
%     Args = [ [nfs_prot3_xdr:enc_read3args({{Obj},O,C})]  || {O,C} <- Chunks],
%     Requests = [ {'$gen_call', {self(), make_ref()}, {call, 6, Arg, 10000} } || Arg <- Args],
%     [C 1]
%     Self ! {done, []}
%   end),
%   erlang:monitor(process, Worker),
%   Bin = receive
%     {done, Data} -> iolist_to_binary(Data);
%     {'DOWN', _, _, Worker, Reason} -> error(Reason)
%   end,
%   {ok, Bin}.


chunks(Offset, Count, ReadSize) when Count > ReadSize ->
  [{Offset, ReadSize}|chunks(Offset + ReadSize, Count - ReadSize, ReadSize)];
chunks(Offset, Count, _) ->
  [{Offset, Count}].


pread(#remote{c = C, read_size = ReadSize}, Obj, Offset, Count) ->
  Chunks = chunks(Offset, Count, ReadSize),
  Blocks = [pread0(C, Obj, O,S) || {O,S} <- Chunks],
  {ok, iolist_to_binary(Blocks)}.


pread0(C, Obj, Offset, Count) ->
  {ok, {'NFS3_OK', {_Attr, _ReadCount, _Eof, Data}}} = nfs_prot3_clnt:nfsproc3_read_3(C, {{Obj}, Offset, Count}),
  Data.



read_file(#remote{} = Remote, Path) ->
  {ok, {Obj, #file_info{size = Size}}, Remote1} = lookup_path(Remote, Path),
  {ok, Bin} = pread(Remote, Obj, 0, Size),
  {ok, Bin, Remote1}.



split(Path) -> [Seg || Seg <- filename:split(iolist_to_binary(Path)), not lists:member(Seg, bad_segments())].
bad_segments() ->
  [<<"/">>, <<".">>, <<"..">>, <<"">>].

join([]) -> <<>>;
join(Segments) -> filename:join([Seg || Seg <- Segments, not lists:member(Seg, bad_segments())]).





lookup_path(#remote{root = Root} = Remote, Path) ->
  Segments = split(Path),
  {ok, Reply, Remote1} = lookup_path1(Remote, Root, Segments, []),
  {ok, Reply, Remote1}.


lookup_path1(#remote{cache = Cache} = Remote, Object, [], PathSegments) ->
  CleanPath = join(PathSegments),
  {ok, {Object, undefined}, Remote#remote{cache = [{CleanPath, Object, undefined}|Cache]}};

lookup_path1(#remote{cache = Cache} = Remote, Root, [Path|Segments], PathSegments1) ->
  PathSegments = PathSegments1 ++ [Path],
  CleanPath = join(PathSegments),
  Reply2 = {ok, {Obj2,_Attr2}, Remote2} = case lists:keyfind(CleanPath, #entry.path, Cache) of
    #entry{object = Obj, attr = Attr} ->
      {ok, {Obj,Attr}, Remote#remote{cache_hit = Remote#remote.cache_hit+1}};
    false ->
      {ok, {Obj,Attr} = Reply} = lookup_path2(Remote, Root, [Path|Segments]),
      {ok, Reply, Remote#remote{cache = [#entry{path = CleanPath,object = Obj, attr = Attr}|Cache]}}
  end,
  case Segments of
    [] -> Reply2;
    _ -> lookup_path1(Remote2, Obj2, Segments, PathSegments)
  end.

attr(Attr) ->
  [Type_, Mode, Nlinks, Uid, Gid, Size, _Used, _Rdev, _Fsid, Inode, {Atime,_}, {Mtime,_}, {Ctime,_}] = tuple_to_list(Attr),
  Type = case Type_ of
    'NF3REG' -> regular;
    'NF3DIR' -> directory;
    'NF3BLK' -> device;
    'NF3CHR' -> device;
    'NF3LNK' -> symlink;
    _ -> other
  end,
  FileInfo = #file_info{
    size = Size,
    type = Type,
    access = undefined,
    atime = Atime,
    mtime = Mtime,
    ctime = Ctime,
    mode = Mode,
    links = Nlinks,
    inode = Inode,
    uid = Uid,
    gid = Gid
  },
  FileInfo.

lookup_path2(#remote{c = C}, Root, [Path|_] = Segments) ->
  {Obj,Attr} = case nfs_prot3_clnt:nfsproc3_lookup_3(C, {{{Root},Path}}) of
    {ok, {'NFS3_OK', {{Obj_},{true,Attr_},_B}}} -> {Obj_, Attr_};
    {ok, {'NFS3ERR_NOENT', _}} -> throw({enoent, Root, Segments})
  end,
  {ok, {Obj, attr(Attr)}}.



list_dir(#remote{c = C, cookie_verf = CV1} = Remote, Path) ->
  {ok, {Obj, _}, Remote1} = lookup_path(Remote, Path),
  case nfs_prot3_clnt:nfsproc3_readdir_3(C, {{Obj}, 0, CV1, 1024*1024}) of
    {ok, {'NFS3_OK', {_Attr,CV2,{Dirs,true}}}} ->
      {ok, lists:sort([F || {F,_,_} <- read_entries(Dirs)]), Remote1#remote{cookie_verf = CV2}};
    {ok, {'NFS3ERR_NOTDIR', _}} ->
      {error, enotdir}
  end.



scan(Remote) ->
  scan(Remote, "").

scan(Remote, Path) ->
  {ok, {Obj, _}, Remote1} = lookup_path(Remote, Path),
  R = scan1(Remote1, [], [{join(split(Path)),Obj}], []),
  R.


  % case nfs_prot3_clnt:nfsproc3_readdir_3(C, {{Obj}, 0, CV1, 1024*1024}) of
  %   {ok, {'NFS3_OK', {_Attr,CV2,{Dirs,true}}}} ->
  %     {ok, lists:sort([F || {F,_,_} <- read_entries(Dirs)]), Remote1#remote{cookie_verf = CV2}};
  %   {ok, {'NFS3ERR_NOTDIR', _}} ->
  %     {error, enotdir}
  % end.

scan1(Remote, Replies, [], []) ->
  {ok, Replies, Remote};

scan1(Remote, Replies, JobQueue, RunQueue) when JobQueue == [] orelse length(RunQueue) > 100 ->
  scan1_wait(Remote, Replies, JobQueue, RunQueue);

scan1(#remote{cookie_verf = CV1, c = C} = Remote, Replies, [{Path,Obj}|JobQueue], RunQueue) ->
  ReadDirPlus = {{Obj}, 0, CV1, 128*1024*1024, 128*1024*1024},
  Call = {call, 17, [nfs_prot3_xdr:enc_readdirplus3args(ReadDirPlus)], 1000},
  Ref = make_ref(),
  GenCall = {'$gen_call', {self(), Ref}, Call},
  C ! GenCall,
  scan1(Remote, Replies, JobQueue, [{Ref, Path, Obj}|RunQueue]).


scan1_wait(#remote{cache = Cache} = Remote, Replies, JobQueue, RunQueue) ->
  length(RunQueue) > 0 orelse error(error_wait),
  % {ok, Stats} = rpc_client:get_stats(Remote#remote.c),
  % Pending = proplists:get_value(pending_requests, Stats),
  % io:format("JobQueue: ~B,  Run queue: ~B/~p (~p)~n", [length(JobQueue), length(RunQueue), Pending, RunQueue]),
  receive
    {Ref, {ok, XDR}} when is_reference(Ref) ->
      {value, {Ref, Path, _Obj}, RunQueue1} = lists:keytake(Ref, 1, RunQueue),
      {{'NFS3_OK', {_Attr, CV2, {Entries, true}}}, _} = nfs_prot3_xdr:dec_readdirplus3res(XDR, 0),
      PathEntries = [E#entry{path = join([Path, P])} || #entry{path = P} = E <- read_entries(Entries), 
        P =/= <<".">> andalso P =/= <<"..">>],
      Cache1 = lists:ukeymerge(#entry.path, lists:sort(PathEntries), Cache),
      SubDirs = [{P,O} || #entry{path = P, object = O, attr = #file_info{type = directory}} <- PathEntries],
      SubFiles = [P || #entry{path = P, attr = #file_info{type = regular}} <- PathEntries],
      % io:format("SubDirs: ~p, SubFiles: ~p~n", [[P || {P,_} <- SubDirs], SubFiles]),
      scan1(Remote#remote{cache = Cache1, cookie_verf = CV2}, SubFiles ++ Replies, SubDirs ++ JobQueue, RunQueue1);
    {Ref, {error, timeout}} ->
      {value, {Ref, Path, Obj}, RunQueue1} = lists:keytake(Ref, 1, RunQueue),
      io:format("timeout scan ~s~n",[Path]),
      scan1(Remote, Replies, [{Path,Obj}|JobQueue], RunQueue1)
  end.

read_entries({_,Path,_,{true,Attr},{true,{Obj}},Next}) ->
  [#entry{path = Path, object = Obj, attr = attr(Attr)}|read_entries(Next)];
read_entries(void) -> [].



% scan1(Remote, ScanQueue, WorkQueue) ->
%   case list_dir(Remote, Path) of
%     {ok, Files, Remote1} ->
%       io:format("list(~s) -> ~B~n", [Path, length(Files)]),

%       {Total, Remote2} = lists:foldl(fun(File, {Total_, Remote1_}) ->
%         {ok, List, Remote2_} = scan1(Remote1_, filename:join(Path, File)),
%         {Total_ ++ List, Remote2_}
%       end, {[], Remote1}, Files),

%       {ok, Total, Remote2};
%     {error, enotdir} ->
%       {ok, [Path], Remote}
%   end.










mkdir_p(#remote{c = C} = Remote, Path) ->
  try lookup_path(Remote, Path) of
    {ok, {Obj,_}, Remote1} -> {ok, Obj, Remote1}
  catch
    throw:{enoent, Root, Segments} ->
      io:format("create ~p under ~p~n",[Segments, Root]),
      {ok, Obj} = mkdir_p_r(C, Root, Segments),
      {ok, Obj, Remote}
  end.

mkdir_p_r(_C, Obj, []) -> {ok, Obj};
mkdir_p_r(C, Obj, [Path|Segments]) ->
  % {Mega,Sec,_} = os:timestamp(),
  % _Now = Mega*1000000 + Sec,
  {ok, {'NFS3_OK', Reply}} = nfs_prot3_clnt:nfsproc3_mkdir_3(C, {{{Obj}, Path}, {
    {true,8#0755},{false,void},{false,void},{false,void},{'DONT_CHANGE',void},{'DONT_CHANGE',void}
  }}),
  { {true, {FH}}, _, _} = Reply,
  mkdir_p_r(C, FH, Segments).


create(Remote, Path) ->
  create(Remote, Path, [{mode, 8#0644}]).

create(#remote{c = C, cache = Cache} = Remote, Path, Options) ->
  {ok, Dir, Remote1} = mkdir_p(Remote, filename:dirname(Path)),

  Name = iolist_to_binary(filename:basename(Path)),
  Mode = proplists:get_value(mode, Options, 8#0644),
  SAttr = {
    {true,Mode},{false,void},{false,void},{false,void},{'DONT_CHANGE',void},{'DONT_CHANGE',void}
  },
  {ok, {'NFS3_OK', Reply}} = nfs_prot3_clnt:nfsproc3_create_3(C, {{{Dir}, Name}, {'UNCHECKED', SAttr}}),
  { {true,{Obj}}, {true, Attr}, _} = Reply,
  CleanPath = join(split(Path)),
  {ok, Obj, Remote1#remote{cache = [#entry{path = CleanPath, object = Obj, attr = attr(Attr)}|Cache]}}.


write(#remote{c = C} = _Remote, Obj, Offset, Data) when is_binary(Data) ->
  {ok, {'NFS3_OK', _Reply}} = nfs_prot3_clnt:nfsproc3_write_3(C, {{Obj}, Offset, size(Data), 'UNSTABLE', Data}),
  ok.


delete_r(#remote{root = Root} = Remote, Path) ->
  Segments = split(Path),
  try delete_r1(Remote, Root, Segments, []) of
    {ok, Remote1} -> {ok, Remote1}
  catch
    throw:{enoent, _, _} -> {error, enoent, Remote}
  end.

delete_r1(#remote{} = Remote, _, [], _) ->
  {ok, Remote};

delete_r1(#remote{cache = Cache, c = C} = Remote, Dir, [Segment], PathSegments1) ->
  PathSegments = PathSegments1 ++ [Segment],
  Cache1 = lists:keydelete(join(PathSegments), #entry.path, Cache),
  case nfs_prot3_clnt:nfsproc3_remove_3(C, {{{Dir}, Segment}}) of
    {ok, {'NFS3_OK', _Reply}} ->
      {ok, Remote#remote{cache = Cache1}};
    {ok, {'NFS3ERR_NOENT', _Reply}} ->
      {error, enoent, Remote#remote{cache = Cache1}}
  end;

delete_r1(#remote{c = C, cookie_verf = CV1} = Remote, Dir, [Segment|Segments], PathSegments1) ->
  PathSegments = PathSegments1 ++ [Segment],
  CleanPath = join(PathSegments),
  {ok, {Obj,_}, Remote1} = lookup_path(Remote, CleanPath),
  #remote{cache = Cache} = Remote2 = case delete_r1(Remote1, Obj, Segments, PathSegments) of
    {ok, Remote2_} -> Remote2_;
    {error, _Error, Remote2_} -> Remote2_
  end,
  {ok, {'NFS3_OK', {_Attr,CV2,{Dirs,true}}}} = nfs_prot3_clnt:nfsproc3_readdir_3(C, {{Obj}, 0, CV1, 1024*1024}),
  {ok, Remote3} = case length(read_entries(Dirs)) of
    0 ->
      {ok, {'NFS3_OK', _}} = nfs_prot3_clnt:nfsproc3_rmdir_3(C, {{{Dir}, Segment}}),
      {ok, Remote2#remote{cache = lists:keydelete(CleanPath, #entry.path, Cache)}};
    _ ->
      {ok, Remote2}
  end,
  {ok, Remote3#remote{cookie_verf = CV2}}.




